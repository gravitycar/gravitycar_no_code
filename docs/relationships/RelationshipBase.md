# RelationshipBase Class and its subclasses

## Purpose
Describes the base class for all relationship types in the Gravitycar framework, providing common functionality for managing relationships between models.
Describes the subclasses for one-to-one, one-to-many, and many-to-many relationships.
These relationships will be managed in join tables in the database. 
The schema of these join tables will be partially defined by relationship metadata and partially generated by the RelationshipBase class or its subclasses.
IMPORTANT - The RelationshipBase class extends the ModelBase class to inherit common model functionality.
This includes the core fields for all Models, such as `id`, `created_at`, `updated_at`, and `deleted_at` (for soft deletes).

## Architecture Overview

### RelationshipFactory
**Purpose**: Centralized factory for creating, validating, and managing relationship instances. Similar to FieldFactory, this handles all cross-cutting concerns that don't belong in individual relationship classes.

**Location**: `src/Factories/RelationshipFactory.php`

**Key Responsibilities**:
- **Relationship Instantiation**: Create relationship instances via DI system using ServiceLocator
- **Metadata Validation**: Validate relationship metadata before instantiation
- **Duplicate Prevention**: Prevent duplicate relationship definitions across the system
- **Circular Dependency Detection**: Detect and prevent circular relationship chains
- **Relationship Registry**: Maintain registry of all created relationships
- **Memory Management**: Handle cleanup of relationships with no loaded related data

```php
class RelationshipFactory {
    protected object $model;
    protected Logger $logger;
    protected array $availableRelationshipTypes = [];
    protected array $relationshipRegistry = [];
    protected array $relationshipKeys = [];
    
    public function __construct(object $model, Logger $logger) {
        $this->model = $model;
        $this->logger = $logger;
        $this->discoverRelationshipTypes();
    }

    /**
     * Create a relationship instance from metadata
     */
    public function createRelationship(array $metadata): RelationshipBase {
        // Validate metadata
        $this->validateRelationshipMetadata($metadata);
        
        // Check for duplicates
        $this->checkForDuplicateRelationships($metadata);
        
        // Check for circular dependencies
        $this->detectCircularDependencies($metadata);
        
        // Create instance via ServiceLocator
        $type = $metadata['type'];
        $className = $this->availableRelationshipTypes[$type] ?? "Gravitycar\\Relationships\\{$type}Relationship";
        
        if (!class_exists($className)) {
            throw new GCException("Relationship class not found for type: $type",
                ['relationship_type' => $type, 'expected_class' => $className]);
        }
        
        $relationship = \Gravitycar\Core\ServiceLocator::createRelationship($className, $metadata);
        
        // Register the relationship
        $this->registerRelationship($relationship, $metadata);
        
        return $relationship;
    }
    
    /**
     * Prevent duplicate relationship definitions
     */
    protected function checkForDuplicateRelationships(array $metadata): void {
        $relationshipKey = $this->generateRelationshipKey($metadata);
        
        if (isset($this->relationshipKeys[$relationshipKey])) {
            throw new GCException(
                'Duplicate relationship definition detected',
                [
                    'relationship_key' => $relationshipKey,
                    'new_relationship' => $metadata['name'],
                    'existing_relationship' => $this->relationshipKeys[$relationshipKey],
                    'suggestion' => 'Use different relationship names or purposes to distinguish multiple relationships between the same models'
                ]
            );
        }
    }

    /**
     * Generate normalized relationship key for duplicate detection
     */
    private function generateRelationshipKey(array $metadata): string {
        $models = [
            $metadata['modelA'] ?? $metadata['modelOne'], 
            $metadata['modelB'] ?? $metadata['modelMany']
        ];
        
        // Sort alphabetically to ensure consistent ordering
        // This makes Userâ†’Role and Roleâ†’User generate the same key for duplicate detection
        sort($models);
        
        // Include relationship type to allow different types between same models
        return implode('_', $models) . '_' . $metadata['type'];
    }

    /**
     * Detect circular dependency chains in relationship definitions
     */
    protected function detectCircularDependencies(array $metadata): void {
        $modelA = $metadata['modelA'] ?? $metadata['modelOne'];
        $modelB = $metadata['modelB'] ?? $metadata['modelMany'];
        
        // Note: Circular dependency detection depth limits will be addressed
        // when we better understand our needs. For now, implement basic detection.
        if ($this->hasCircularDependency($modelA, $modelB)) {
            throw new GCException(
                'Circular dependency detected in relationship definition',
                [
                    'relationship' => $metadata['name'],
                    'models' => [$modelA, $modelB],
                    'suggestion' => 'Review relationship chain to prevent circular references'
                ]
            );
        }
    }
    
    /**
     * Register relationship in factory registry
     */
    protected function registerRelationship(RelationshipBase $relationship, array $metadata): void {
        $relationshipKey = $this->generateRelationshipKey($metadata);
        
        $this->relationshipRegistry[$metadata['name']] = [
            'instance' => $relationship,
            'metadata' => $metadata,
            'key' => $relationshipKey,
            'hasLoadedData' => false // Track for memory management
        ];
        
        $this->relationshipKeys[$relationshipKey] = $metadata['name'];
    }

    /**
     * Clean up relationships with no loaded related data (weak references)
     */
    public function cleanupEmptyRelationships(): void {
        foreach ($this->relationshipRegistry as $name => $entry) {
            if (!$entry['hasLoadedData']) {
                unset($this->relationshipRegistry[$name]);
                unset($this->relationshipKeys[$entry['key']]);
            }
        }
    }

    /**
     * Mark relationship as having loaded data
     */
    public function markRelationshipLoaded(string $relationshipName): void {
        if (isset($this->relationshipRegistry[$relationshipName])) {
            $this->relationshipRegistry[$relationshipName]['hasLoadedData'] = true;
        }
    }

    /**
     * Get all available relationship types
     */
    public function getAvailableRelationshipTypes(): array {
        return array_keys($this->availableRelationshipTypes);
    }

    /**
     * Scan src/relationships directory for available relationship types
     */
    protected function discoverRelationshipTypes(): void {
        $relationshipsDir = __DIR__ . '/../relationships';
        if (!is_dir($relationshipsDir)) {
            $this->logger->warning("Relationships directory not found: $relationshipsDir");
            return;
        }
        
        $files = scandir($relationshipsDir);
        foreach ($files as $file) {
            if (preg_match('/^(.*)Relationship\.php$/', $file, $matches)) {
                $type = $matches[1];
                $this->availableRelationshipTypes[$type] = "Gravitycar\\Relationships\\{$type}Relationship";
            }
        }
    }
}
```

### RelationshipFactory Integration with ModelBase
```php
// In ModelBase, relationships should be created via RelationshipFactory
protected RelationshipFactory $relationshipFactory;

protected function initializeRelationships(): void {
    $this->relationshipFactory = new RelationshipFactory($this, $this->logger);
    
    $relationshipMetadata = $this->getRelationshipMetadata();
    foreach ($relationshipMetadata as $name => $metadata) {
        $relationship = $this->relationshipFactory->createRelationship($metadata);
        $this->relationships[$name] = $relationship;
    }
}

public function getRelationship(string $name): ?RelationshipBase {
    return $this->relationships[$name] ?? null;
}
```

## Relationship Types
- **OneToOne**: `src/relationships/OneToOneRelationship.php`
- **OneToMany**: `src/relationships/OneToManyRelationship.php`
- **ManyToMany**: `src/relationships/ManyToManyRelationship.php`

IMPORTANT: Keep future-proofing in mind. The design should allow for easy addition of new relationship types in the future.

## Data Retrieval Strategy

### Database Records vs Model Instances
**IMPORTANT**: Relationship query methods should return raw database records as associative arrays, NOT instantiated model objects. This approach provides:

- **Performance Benefits**: Avoids expensive object instantiation overhead
- **Memory Efficiency**: Raw arrays use significantly less memory than full model objects
- **Flexibility**: Calling code can decide whether to instantiate models or work with raw data
- **Circular Dependency Prevention**: Prevents infinite loops when loading related data

```php
// Correct approach - return database records
public function getRelatedRecords(ModelBase $model): array {
    $sql = "SELECT * FROM {$this->getRelatedTableName()} WHERE {$this->getModelIdField($model)} = ?";
    $stmt = $this->getDatabaseConnector()->prepare($sql);
    $stmt->execute([$model->get('id')]);
    
    // Return raw database records as associative arrays
    return $stmt->fetchAll(\PDO::FETCH_ASSOC);
}

// Model instantiation happens at the application layer if needed
public function getRelatedModels(ModelBase $model): array {
    $records = $this->getRelatedRecords($model);
    $models = [];
    
    foreach ($records as $record) {
        // Only instantiate when explicitly requested
        $relatedModelClass = $this->getRelatedModelClass($model);
        $models[] = new $relatedModelClass($record);
    }
    
    return $models;
}
```

### Memory Management for Weak References
The RelationshipFactory implements weak references by tracking relationships that have no loaded related data:

```php
// In RelationshipFactory
protected function registerRelationship(RelationshipBase $relationship, array $metadata): void {
    $relationshipKey = $this->generateRelationshipKey($metadata);
    
    $this->relationshipRegistry[$metadata['name']] = [
        'instance' => $relationship,
        'metadata' => $metadata,
        'key' => $relationshipKey,
        'hasLoadedData' => false // Initially no data loaded
    ];
    
    $this->relationshipKeys[$relationshipKey] = $metadata['name'];
}

/**
 * Clean up relationships with no loaded related data (weak references)
 * This prevents memory buildup from unused relationship instances
 */
public function cleanupEmptyRelationships(): void {
    foreach ($this->relationshipRegistry as $name => $entry) {
        if (!$entry['hasLoadedData']) {
            unset($this->relationshipRegistry[$name]);
            unset($this->relationshipKeys[$entry['key']]);
        }
    }
}
```

## Core Properties
- **`name`**: Unique identifier for the relationship
- **`type`**: The type of relationship (OneToOne, OneToMany, ManyToMany)
- **`metadata`**: An array containing the data for the relationship, including:
  - **`modelA` OR `modelOne`**: The first model involved in the relationship (class name)
  - **`modelB`** OR `modelMany`: The second model involved in the relationship (class name)
  - **`constraints`**: An array of constraints such as cascade delete options, uniqueness, and bidirectionality
  - **`additionalFields`**: An array of additional fields to be stored in the join table (for ManyToMany relationships)
- **`tableName`**: The name of the join table in the database - generated based on the relationship type and involved models


## Generating the Join Table Name
- Models have their table names set by their metadata. Relationships, however, generate their join table names based on the relationship type and the involved models.
- For one-to-one relationships, the table name will be `rel_1_<model_a>_1_<model_b>`.
- For one-to-many relationships, the table name will be `rel_1_<model_one>_M_<model_many>`.
- For many-to-many relationships, the table name will be `rel_N_<model_a>_M_<model_b>`.
- Ensure the resulting table name does not exceed database limits (e.g., 64 characters for MySQL). If it does, truncate model names as needed.

## Complete Metadata Structure

### Required Metadata Fields
All relationship types MUST include:
```php
[
    'name' => 'relationship_unique_name',     // Unique identifier
    'type' => 'OneToOne|OneToMany|ManyToMany', // Relationship type
]
```

Any relationship type MAY include:
```php
    'constraints' => [                        // Optional constraints
        'unique' => true,                     // For OneToOne only
        'cascadeDelete' => 'restrict|cascade|setNull', // Default: 'restrict'
        'bidirectional' => true,              // Default: true
    ],
    'additionalFields' => [                   // Optional additional fields
        'field_name' => [
            'type' => 'TextField',
            'label' => 'Additional Data',
            'required' => false
        ]
    ]
```

### OneToOne Specific Metadata
```php
[
    'name' => 'users_profiles',
    'type' => 'OneToOne',
    'modelA' => 'Users',
    'modelB' => 'Profile',
]
```

### OneToMany Specific Metadata
```php
[
    'name' => 'user_posts',
    'type' => 'OneToMany',
    'modelOne' => 'User',                     // The "one" side
    'modelMany' => 'Post',                    // The "many" side
]
```

### ManyToMany Specific Metadata
```php
[
    'name' => 'user_roles',
    'type' => 'ManyToMany',
    'modelA' => 'User',
    'modelB' => 'Role',
]
```

## Metadata Validation Rules
1. **Required Fields**: Ensure all required fields are present based on relationship type

### Core Validation Requirements
1. **Model Existence**: Both referenced models MUST exist as valid ModelBase subclasses
2. **Circular Dependency Prevention**: Detect and prevent circular relationship chains
3. **Unique Naming**: Relationship names must be unique across the entire application
4. **Type-Specific Validation**: Each relationship type has specific validation rules

### Validation Implementation
```php
protected function validateRelationshipMetadata(array $metadata): void {
    // Required field validation
    $this->validateRequiredFields($metadata);
    
    // Model existence validation
    $this->validateModelsExist($metadata);
    
    // Circular dependency check
    $this->validateNoCircularDependencies($metadata);
    
    // Type-specific validation
    $this->validateTypeSpecificConstraints($metadata);
    
    // Additional fields validation
    $this->validateAdditionalFields($metadata);
}
```

### Specific Validation Rules by Type

#### OneToOne Validation
- MUST have 'unique' => true constraint
- Both models should not already have OneToOne relationship with each other
- Cascade delete options: 'restrict', 'cascade', 'setNull'

#### OneToMany Validation  
- MUST specify which model is "one" (modelOne) and which is "many" (modelMany)
- Validate orderBy field exists on "many" model if specified
- Cannot have OneToMany between same models in both directions

#### ManyToMany Validation
- Additional fields must not conflict with generated ID fields
- Validate all additional field types are valid FieldBase subclasses

## Dynamic Metadata Fields Generation
- Unlike models, relationships will generate the metadata for some of their fields based on the models in the given metadata and relationship type. 

### One-to-One relationships
- For One-to-One relationships, the metadata MUST define fields to represent the two models involved. These models are referred to as model_a and model_b.
- Other fields may be defined in the metadata, but the two ID fields for the models MUST be generated. The core fields for all models will be collected from CoreFieldsMetadata, as they are ModelBase subclasses.
- Example metadata for the two ID fields to be generated for a One-to-One relationship:
```php
[
    'name' => '<model_a_name>_id',
    'type' => 'IDField',
    'label' => '<Model A Display Name> ID',
    'required' => true,
    'relatedModel' => '<ModelAClassName>'
    'relatedField' => 'id' // Optional, defaults to 'id'
    'validationRules' => [
        'Unique' => true // Enforce uniqueness for One-to-One
        'ForeignKeyExists' => true // Enforce foreign key constraint
    ]
],
[
    'name' => '<model_b_name>_id', 
    'type' => 'IDField',
    'label' => '<Model B Display Name> ID',
    'required' => true,
    'relatedModel' => '<ModelBClassName>'
    'relatedField' => 'id' // Optional, defaults to 'id'
    'validationRules' => [
        'Unique' => true // Enforce uniqueness for One-to-One
        'ForeignKeyExists' => true // Enforce foreign key constraint
    ]
}
```

### One-to-Many relationships
- Generate ID field for "one" model and ID field for "many" model
```php
[
    'name' => 'one_<model_one_name>_id',
    'type' => 'IDField',
    'label' => '<Model One Display Name> ID', 
    'required' => true,
    'relatedModel' => '<ModelOneClassName>'
    'relatedField' => 'id' // Optional, defaults to 'id'
    'validationRules' => [
        'ForeignKeyExists' => true // Enforce foreign key constraint
    ]
],
[
    'name' => 'many_<model_many_name>_id',
    'type' => 'IDField',
    'label' => '<Model Many Display Name> ID',
    'required' => true, 
    'relatedModel' => '<ModelManyClassName>'
    'relatedField' => 'id' // Optional, defaults to 'id'
    'validationRules' => [
        'ForeignKeyExists' => true // Enforce foreign key constraint
    ]
]
```

### Many-to-Many relationships
- Generate ID fields for both models involved
```php
[
    'name' => '<model_a_name>_id',
    'type' => 'IDField',
    'label' => '<Model A Display Name> ID',
    'required' => true,
    'relatedModel' => '<ModelAClassName>'
    'relatedField' => 'id' // Optional, defaults to 'id'
    'validationRules' => [
        'ForeignKeyExists' => true // Enforce foreign key constraint
    ]
],
[
    'name' => '<model_b_name>_id',
    'type' => 'IDField', 
    'label' => '<Model B Display Name> ID',
    'required' => true,
    'relatedModel' => '<ModelBClassName>'
    'relatedField' => 'id' // Optional, defaults to 'id'
    'validationRules' => [
        'ForeignKeyExists' => true // Enforce foreign key constraint
    ]
}
```

## Error Handling and Edge Cases

### Circular Dependency Detection
```php
protected function detectCircularDependencies(string $modelA, string $modelB, array $checkedPath = []): bool {
    // Implement graph traversal to detect cycles in relationship definitions
    // Return true if circular dependency found
}
```

### Self-Referential Relationships
Support for models that relate to themselves:
```php
[
    'type' => 'OneToMany',
    'modelOne' => 'User', // Manager
    'modelMany' => 'User', // Subordinates
    'name' => 'manager_subordinates',
    'selfReferential' => true
]
```

### Multiple Relationships Between Same Models
Allow multiple relationships between the same two models with different purposes:
```php
// User -> User (Manager relationship)
['name' => 'manager_subordinates', 'type' => 'OneToMany', 'modelOne' => 'User', 'modelMany' => 'User']

// User -> User (Friendship relationship) 
['name' => 'friendships', 'type' => 'ManyToMany', 'modelA' => 'User', 'modelB' => 'User']
```

## Next Steps
This addresses **#1: Metadata Validation & Constraints** from our implementation plan. The complete metadata structure is now defined with comprehensive validation rules for each relationship type.

## Bidirectional Relationship Management

### Purpose
Ensure relationships work seamlessly in both directions (e.g., User -> Posts and Posts -> User) while preventing duplicate definitions and maintaining consistency.

### Bidirectional Access Patterns
```php
// From User model - get all posts
$user = User::findById('user-123');
$posts = $user->getRelated('user_posts'); // Returns Post[] array

// From Post model - get the user
$post = Post::findById('post-456'); 
$user = $post->getRelated('user_posts'); // Returns User object
```

### Automatic Inverse Relationship Generation
When a relationship is defined, the system automatically creates the inverse relationship:

```php
// Original relationship definition
[
    'name' => 'user_posts',
    'type' => 'OneToMany',
    'modelOne' => 'User',
    'modelMany' => 'Post'
]

// Automatically generated inverse (internal)
[
    'name' => 'user_posts_inverse',
    'type' => 'ManyToOne', // Inverse of OneToMany
    'modelMany' => 'User', // Swapped roles
    'modelOne' => 'Post',
    'inverseName' => 'user_posts', // Reference to original
    'isAutoGenerated' => true
]
```

### Bidirectional Relationship Rules

#### OneToOne Relationships
- Both models can access the related model directly
- Inverse relationship is also OneToOne
- Example: User â†” Profile

```php
// User -> Profile
$user->getRelated('user_profile'); // Returns Profile object

// Profile -> User  
$profile->getRelated('user_profile'); // Returns User object
```

#### OneToMany Relationships
- "One" side accesses array of "many" objects
- "Many" side accesses single "one" object
- Example: User(1) â†” Posts(M)

```php
// User -> Posts (one-to-many)
$user->getRelated('user_posts'); // Returns Post[] array

// Post -> User (many-to-one inverse)
$post->getRelated('user_posts'); // Returns User object
```

#### ManyToMany Relationships
- Both sides access arrays of related objects
- Inverse relationship is also ManyToMany
- Example: Users(M) â†” Roles(M)

```php
// User -> Roles
$user->getRelated('user_roles'); // Returns Role[] array

// Role -> Users
$role->getRelated('user_roles'); // Returns User[] array
```

### Preventing Duplicate Relationship Definitions
```php
protected function validateNoDuplicateRelationships(array $metadata): void {
    $relationshipKey = $this->generateRelationshipKey($metadata);
    
    if ($this->relationshipExists($relationshipKey)) {
        throw new GCException(
            'Duplicate relationship definition detected',
            [
                'relationship_key' => $relationshipKey,
                'existing_relationship' => $this->getExistingRelationship($relationshipKey)
            ]
        );
    }
}

private function generateRelationshipKey(array $metadata): string {
    $models = [$metadata['modelA'] ?? $metadata['modelOne'], 
               $metadata['modelB'] ?? $metadata['modelMany']];
    sort($models); // Ensure consistent ordering
    return implode('_', $models) . '_' . $metadata['type'];
}
```

### Relationship Naming Conventions
- Primary relationship: `<model_one>_<model_many>` or `<model_a>_<model_b>`
- Inverse relationship: `<primary_name>_inverse` (internal only)
- Multiple relationships: `<model_a>_<model_b>_<purpose>`

Examples:
```php
'user_posts'           // User -> Posts
'user_profile'         // User -> Profile  
'user_roles'           // User -> Roles
'user_manager'         // User -> User (manager relationship)
'user_friends'         // User -> User (friendship relationship)
```

## Relationship Query Methods

### Core Query Methods
All RelationshipBase subclasses must implement these essential query methods:

```php
// Get all related records for a given model instance
public function getRelatedRecords(ModelBase $model): array;

// Add a new relationship record
public function addRelation(ModelBase $modelA, ModelBase $modelB, array $additionalData = []): bool;

// Remove a relationship record
public function removeRelation(ModelBase $modelA, ModelBase $modelB): bool;

// Check if a relationship exists between two models
public function hasRelation(ModelBase $modelA, ModelBase $modelB): bool;

// Get relationship record with additional fields
public function getRelationshipRecord(ModelBase $modelA, ModelBase $modelB): ?ModelBase;

// Update additional fields in a relationship
public function updateRelation(ModelBase $modelA, ModelBase $modelB, array $additionalData): bool;
```

### Type-Specific Query Implementations

#### OneToOne Query Methods
```php
// Get the single related record
public function getRelatedRecord(ModelBase $model): ?ModelBase {
    $records = $this->getRelatedRecords($model);
    return empty($records) ? null : $records[0];
}

// Set or replace the relationship (removes existing if present)
public function setRelation(ModelBase $modelA, ModelBase $modelB): bool {
    // Remove existing relationship first
    $this->removeAllRelations($modelA);
    return $this->addRelation($modelA, $modelB);
}
```

#### OneToMany Query Methods
```php
// Get all related records from "many" side
public function getRelatedFromMany(ModelBase $manyModel): ?ModelBase {
    $records = $this->getRelatedRecords($manyModel);
    return empty($records) ? null : $records[0]; // Single "one" record
}

// Get all related records from "one" side
public function getRelatedFromOne(ModelBase $oneModel): array {
    return $this->getRelatedRecords($oneModel); // Array of "many" records
}

// Add relationship with ordering support
public function addRelationWithOrder(ModelBase $oneModel, ModelBase $manyModel, int $order = 0): bool {
    return $this->addRelation($oneModel, $manyModel, ['order' => $order]);
}
```

#### ManyToMany Query Methods
```php
// Get all relationships with additional field data
public function getRelatedWithData(ModelBase $model, array $additionalFields = []): array {
    $sql = "SELECT * FROM {$this->getTableName()} WHERE {$this->getModelIdField($model)} = ?";
    if (!empty($additionalFields)) {
        $sql .= " AND " . implode(' AND ', array_map(fn($field) => "$field = ?", array_keys($additionalFields)));
    }
    
    // Implementation details...
}

// Bulk add multiple relationships
public function addMultipleRelations(ModelBase $model, array $relatedModels, array $commonAdditionalData = []): bool {
    foreach ($relatedModels as $relatedModel) {
        if (!$this->addRelation($model, $relatedModel, $commonAdditionalData)) {
            return false;
        }
    }
    return true;
}
```

### Query Optimization Features

#### Eager Loading Support
```php
// Load relationships with the main query to avoid N+1 problems
public static function withRelationships(array $relationshipNames): QueryBuilder {
    // Implementation will add JOINs for specified relationships
}

// Usage example:
$users = User::withRelationships(['user_posts', 'user_profile'])->findAll();
```

#### Lazy Loading with Caching
```php
protected array $relationshipCache = [];

public function getRelated(string $relationshipName): mixed {
    if (!isset($this->relationshipCache[$relationshipName])) {
        $this->relationshipCache[$relationshipName] = $this->loadRelationship($relationshipName);
    }
    return $this->relationshipCache[$relationshipName];
}
```

#### Paginated Relationship Queries
IMPORTANT: Pagination should be the default behavior for all relationships. The default page size is defined in config.php as `default_page_limit` (e.g., 20) but can be overridden with the $perPage argument.
```php
public function getRelatedPaginated(ModelBase $model, int $page = 1, int $perPage = 20): array {
    $offset = ($page - 1) * $perPage;
    // Return both records and pagination metadata
    return [
        'records' => $this->getRelatedRecords($model, $perPage, $offset),
        'pagination' => [
            'current_page' => $page,
            'per_page' => $perPage,
            'total' => $this->getRelatedCount($model),
            'has_more' => $this->hasMoreRelated($model, $page, $perPage)
        ]
    ];
}
```

## Cascade Operations and Data Integrity

### Purpose
Define what happens to relationships when related models are deleted, ensuring data integrity and preventing orphaned records.

### Cascade Delete Options
```php
const CASCADE_RESTRICT = 'restrict';   // Prevent deletion if relationships exist
const CASCADE_CASCADE = 'cascade';     // Delete relationships when model deleted
const CASCADE_SOFT_DELETE = 'softDelete';    // Soft delete relationships when model deleted
const CASCADE_SET_DEFAULT = 'setDefault'; // Set to default value
```

### Soft Delete Behavior in Relationships
**IMPORTANT**: In the Gravitycar framework, soft deletes are performed by setting the `deleted_at` field to the current datetime and the `deleted_by` field to the ID of the currently logged-in user. When a model that participates in relationships is soft-deleted, its relationship records should also be soft-deleted using the same mechanism.

**Performance Consideration**: For relationships with many records (especially ManyToMany), we must avoid running individual UPDATE statements for each relationship record. Instead, we use bulk UPDATE operations to soft-delete all related records in a single query.

### Implementation by Relationship Type

#### OneToOne Cascade Behavior
```php
public function handleModelDeletion(ModelBase $deletedModel, string $cascadeAction): bool {
    switch ($cascadeAction) {
        case self::CASCADE_RESTRICT:
            if ($this->hasActiveRelation($deletedModel)) {
                throw new GCException(
                    'Cannot delete model with existing OneToOne relationship',
                    ['model' => get_class($deletedModel), 'id' => $deletedModel->get('id')]
                );
            }
            return true;
            
        case self::CASCADE_CASCADE:
            $relatedModel = $this->getRelatedRecord($deletedModel);
            if ($relatedModel) {
                return $relatedModel->delete(); // This will cascade further if needed
            }
            return true;
            
        case self::CASCADE_SOFT_DELETE:
            // Soft delete the relationship record itself
            return $this->softDeleteRelationshipRecords($deletedModel);
    }
}

/**
 * Check if model has active (non-soft-deleted) relationships
 */
protected function hasActiveRelation(ModelBase $model): bool {
    $sql = "SELECT COUNT(*) FROM {$this->getTableName()} 
            WHERE {$this->getModelIdField($model)} = ? 
            AND deleted_at IS NULL";
    
    $stmt = $this->getDatabaseConnector()->prepare($sql);
    $stmt->execute([$model->get('id')]);
    
    return $stmt->fetchOne() > 0;
}
```

#### OneToMany Cascade Behavior
```php
public function handleModelDeletion(ModelBase $deletedModel, string $cascadeAction): bool {
    $isOneModel = $this->isOneModel($deletedModel);
    
    if ($isOneModel) {
        // Deleting from "one" side - affects multiple "many" records
        return $this->handleOneModelDeletion($deletedModel, $cascadeAction);
    } else {
        // Deleting from "many" side - affects single "one" relationship
        return $this->handleManyModelDeletion($deletedModel, $cascadeAction);
    }
}

private function handleOneModelDeletion(ModelBase $oneModel, string $cascadeAction): bool {
    switch ($cascadeAction) {
        case self::CASCADE_RESTRICT:
            if ($this->hasActiveRelationsFromOne($oneModel)) {
                throw new GCException(
                    'Cannot delete model with existing OneToMany relationships',
                    [
                        'model' => get_class($oneModel), 
                        'id' => $oneModel->get('id'),
                        'related_count' => $this->getActiveRelatedCount($oneModel)
                    ]
                );
            }
            return true;
            
        case self::CASCADE_CASCADE:
            // Hard delete all related "many" models
            $manyRecords = $this->getRelatedFromOne($oneModel);
            foreach ($manyRecords as $record) {
                if (!$record->delete()) {
                    return false;
                }
            }
            return true;
            
        case self::CASCADE_SOFT_DELETE:
            // Bulk soft delete all relationship records for this "one" model
            return $this->bulkSoftDeleteRelationships($oneModel);
    }
}

/**
 * Bulk soft delete relationship records - optimized for performance
 */
protected function bulkSoftDeleteRelationships(ModelBase $model): bool {
    try {
        $conn = $this->getDatabaseConnector()->getConnection();
        $currentUser = $this->getCurrentUserId();
        $currentDateTime = date('Y-m-d H:i:s');
        
        $sql = "UPDATE {$this->getTableName()} 
                SET deleted_at = ?, deleted_by = ? 
                WHERE {$this->getModelIdField($model)} = ? 
                AND deleted_at IS NULL";
        
        $stmt = $conn->prepare($sql);
        $result = $stmt->executeStatement([
            $currentDateTime,
            $currentUser,
            $model->get('id')
        ]);
        
        $this->logger->info('Bulk soft delete of relationship records completed', [
            'relationship_table' => $this->getTableName(),
            'model_class' => get_class($model),
            'model_id' => $model->get('id'),
            'records_updated' => $result
        ]);
        
        return true;
        
    } catch (\Exception $e) {
        $this->logger->error('Failed to bulk soft delete relationship records', [
            'relationship_table' => $this->getTableName(),
            'model_class' => get_class($model),
            'model_id' => $model->get('id'),
            'error' => $e->getMessage()
        ]);
        
        throw new GCException('Bulk soft delete of relationships failed: ' . $e->getMessage(), [], 0, $e);
    }
}

/**
 * Get currently logged-in user ID for deleted_by field
 */
protected function getCurrentUserId(): ?string {
    // This would integrate with your authentication system
    // For now, return null or a default system user ID
    return ServiceLocator::getCurrentUser()?->get('id') ?? 'system';
}
```

#### ManyToMany Cascade Behavior
```php
public function handleModelDeletion(ModelBase $deletedModel, string $cascadeAction): bool {
    switch ($cascadeAction) {
        case self::CASCADE_RESTRICT:
            if ($this->hasActiveRelations($deletedModel)) {
                throw new GCException(
                    'Cannot delete model with existing ManyToMany relationships',
                    [
                        'model' => get_class($deletedModel), 
                        'id' => $deletedModel->get('id'),
                        'active_relationships' => $this->getActiveRelatedCount($deletedModel)
                    ]
                );
            }
            return true;
            
        case self::CASCADE_CASCADE:
            // For ManyToMany, cascade typically means delete all relationship records
            // but NOT the related models (they may have other relationships)
            return $this->hardDeleteAllRelationships($deletedModel);
            
        case self::CASCADE_SOFT_DELETE:
            // Bulk soft delete all relationship records for this model
            return $this->bulkSoftDeleteRelationships($deletedModel);
    }
}

/**
 * Hard delete all relationship records for a model
 */
protected function hardDeleteAllRelationships(ModelBase $model): bool {
    try {
        $conn = $this->getDatabaseConnector()->getConnection();
        
        $sql = "DELETE FROM {$this->getTableName()} 
                WHERE {$this->getModelIdField($model)} = ?";
        
        $stmt = $conn->prepare($sql);
        $result = $stmt->executeStatement([$model->get('id')]);
        
        $this->logger->info('Hard delete of all relationship records completed', [
            'relationship_table' => $this->getTableName(),
            'model_class' => get_class($model),
            'model_id' => $model->get('id'),
            'records_deleted' => $result
        ]);
        
        return true;
        
    } catch (\Exception $e) {
        $this->logger->error('Failed to hard delete relationship records', [
            'relationship_table' => $this->getTableName(),
            'model_class' => get_class($model),
            'model_id' => $model->get('id'),
            'error' => $e->getMessage()
        ]);
        
        throw new GCException('Hard delete of relationships failed: ' . $e->getMessage(), [], 0, $e);
    }
}

/**
 * Count active (non-soft-deleted) related records
 */
protected function getActiveRelatedCount(ModelBase $model): int {
    $sql = "SELECT COUNT(*) FROM {$this->getTableName()} 
            WHERE {$this->getModelIdField($model)} = ? 
            AND deleted_at IS NULL";
    
    $stmt = $this->getDatabaseConnector()->prepare($sql);
    $stmt->execute([$model->get('id')]);
    
    return (int) $stmt->fetchOne();
}
```

### Soft Delete Integration
```php
public function softDeleteRelationship(ModelBase $modelA, ?ModelBase $modelB = null): bool {
    try {
        $conn = $this->getDatabaseConnector()->getConnection();
        $currentUser = $this->getCurrentUserId();
        $currentDateTime = date('Y-m-d H:i:s');
        
        if ($modelB === null) {
            // Soft delete all relationships for modelA (bulk operation)
            $sql = "UPDATE {$this->getTableName()} 
                    SET deleted_at = ?, deleted_by = ? 
                    WHERE {$this->getModelIdField($modelA)} = ? 
                    AND deleted_at IS NULL";
            
            $stmt = $conn->prepare($sql);
            $result = $stmt->executeStatement([
                $currentDateTime,
                $currentUser,
                $modelA->get('id')
            ]);
            
        } else {
            // Soft delete specific relationship
            $sql = "UPDATE {$this->getTableName()} 
                    SET deleted_at = ?, deleted_by = ? 
                    WHERE {$this->getModelAIdField()} = ? 
                    AND {$this->getModelBIdField()} = ? 
                    AND deleted_at IS NULL";
            
            $stmt = $conn->prepare($sql);
            $result = $stmt->executeStatement([
                $currentDateTime,
                $currentUser,
                $modelA->get('id'),
                $modelB->get('id')
            ]);
        }
        
        $this->logger->info('Relationship soft delete completed', [
            'relationship_table' => $this->getTableName(),
            'model_a_class' => get_class($modelA),
            'model_a_id' => $modelA->get('id'),
            'model_b_class' => $modelB ? get_class($modelB) : null,
            'model_b_id' => $modelB?->get('id'),
            'records_updated' => $result,
            'deleted_by' => $currentUser
        ]);
        
        return $result > 0;
        
    } catch (\Exception $e) {
        $this->logger->error('Failed to soft delete relationship', [
            'relationship_table' => $this->getTableName(),
            'model_a_class' => get_class($modelA),
            'model_a_id' => $modelA->get('id'),
            'model_b_class' => $modelB ? get_class($modelB) : null,
            'model_b_id' => $modelB?->get('id'),
            'error' => $e->getMessage()
        ]);
        
        throw new GCException('Relationship soft delete failed: ' . $e->getMessage(), [], 0, $e);
    }
}

public function restoreRelationship(ModelBase $modelA, ?ModelBase $modelB = null): bool {
    try {
        $conn = $this->getDatabaseConnector()->getConnection();
        
        if ($modelB === null) {
            // Restore all relationships for modelA (bulk operation)
            $sql = "UPDATE {$this->getTableName()} 
                    SET deleted_at = NULL, deleted_by = NULL 
                    WHERE {$this->getModelIdField($modelA)} = ? 
                    AND deleted_at IS NOT NULL";
            
            $stmt = $conn->prepare($sql);
            $result = $stmt->executeStatement([$modelA->get('id')]);
            
        } else {
            // Restore specific relationship
            $sql = "UPDATE {$this->getTableName()} 
                    SET deleted_at = NULL, deleted_by = NULL 
                    WHERE {$this->getModelAIdField()} = ? 
                    AND {$this->getModelBIdField()} = ? 
                    AND deleted_at IS NOT NULL";
            
            $stmt = $conn->prepare($sql);
            $result = $stmt->executeStatement([
                $modelA->get('id'),
                $modelB->get('id')
            ]);
        }
        
        $this->logger->info('Relationship restore completed', [
            'relationship_table' => $this->getTableName(),
            'model_a_class' => get_class($modelA),
            'model_a_id' => $modelA->get('id'),
            'model_b_class' => $modelB ? get_class($modelB) : null,
            'model_b_id' => $modelB?->get('id'),
            'records_restored' => $result
        ]);
        
        return $result > 0;
        
    } catch (\Exception $e) {
        $this->logger->error('Failed to restore relationship', [
            'relationship_table' => $this->getTableName(),
            'model_a_class' => get_class($modelA),
            'model_a_id' => $modelA->get('id'),
            'model_b_class' => $modelB ? get_class($modelB) : null,
            'model_b_id' => $modelB?->get('id'),
            'error' => $e->getMessage()
        ]);
        
        throw new GCException('Relationship restore failed: ' . $e->getMessage(), [], 0, $e);
    }
}

/**
 * Get all active (non-soft-deleted) relationship records for a model
 */
public function getActiveRelationshipRecords(ModelBase $model): array {
    $sql = "SELECT * FROM {$this->getTableName()} 
            WHERE {$this->getModelIdField($model)} = ? 
            AND deleted_at IS NULL";
    
    $stmt = $this->getDatabaseConnector()->prepare($sql);
    $stmt->execute([$model->get('id')]);
    
    return $stmt->fetchAll(\PDO::FETCH_ASSOC);
}

/**
 * Get all soft-deleted relationship records for a model
 */
public function getDeletedRelationshipRecords(ModelBase $model): array {
    $sql = "SELECT * FROM {$this->getTableName()} 
            WHERE {$this->getModelIdField($model)} = ? 
            AND deleted_at IS NOT NULL";
    
    $stmt = $this->getDatabaseConnector()->prepare($sql);
    $stmt->execute([$model->get('id')]);
    
    return $stmt->fetchAll(\PDO::FETCH_ASSOC);
}
```

## Performance Considerations and Optimization

### Database Index Strategy
```php
// RelationshipBase will automatically generate optimal indexes for each relationship type
protected function generateOptimalIndexes(): array {
    $indexes = [];
    
    // Always create indexes on ID fields for fast lookups
    $indexes[] = $this->createIndex([$this->getModelAIdField()], 'model_a_lookup');
    $indexes[] = $this->createIndex([$this->getModelBIdField()], 'model_b_lookup');
    
    // Compound index for relationship existence checks
    $indexes[] = $this->createIndex(
        [$this->getModelAIdField(), $this->getModelBIdField()],
        'relationship_compound',
        ['unique' => $this->isOneToOne()]
    );
    
    // Additional indexes based on additional fields
    foreach ($this->getAdditionalFields() as $field) {
        if ($field['indexed'] ?? false) {
            $indexes[] = $this->createIndex([$field['name']], $field['name'] . '_lookup');
        }
    }
    
    return $indexes;
}
```

### Query Optimization Techniques

#### Batch Operations
```php
public function addMultipleRelationsBatch(ModelBase $model, array $relatedModels, array $commonData = []): bool {
    $batchSize = 1000; // Configurable batch size
    $batches = array_chunk($relatedModels, $batchSize);
    
    foreach ($batches as $batch) {
        $sql = $this->buildBatchInsertSQL(count($batch));
        $params = $this->prepareBatchParams($model, $batch, $commonData);
        
        if (!$this->executeBatchQuery($sql, $params)) {
            return false;
        }
    }
    
    return true;
}

private function buildBatchInsertSQL(int $recordCount): string {
    $tableName = $this->getTableName();
    $fields = array_merge(
        [$this->getModelAIdField(), $this->getModelBIdField()],
        array_keys($this->getAdditionalFields())
    );
    
    $fieldList = implode(', ', $fields);
    $placeholders = str_repeat('(' . str_repeat('?,', count($fields) - 1) . '?),', $recordCount - 1);
    $placeholders .= '(' . str_repeat('?,', count($fields) - 1) . '?)';
    
    return "INSERT INTO {$tableName} ({$fieldList}) VALUES {$placeholders}";
}
```

#### Connection Pooling and Prepared Statements
```php
protected array $preparedStatements = [];

protected function getPreparedStatement(string $key, string $sql): \PDOStatement {
    if (!isset($this->preparedStatements[$key])) {
        $dbConnector = ServiceLocator::getDatabaseConnector();
        $this->preparedStatements[$key] = $dbConnector->prepare($sql);
    }
    
    return $this->preparedStatements[$key];
}

public function getRelatedRecordsOptimized(ModelBase $model): array {
    $stmt = $this->getPreparedStatement(
        'get_related_' . $this->getType(),
        $this->buildGetRelatedSQL()
    );
    
    $stmt->execute([$model->get('id')]);
    return $stmt->fetchAll(\PDO::FETCH_ASSOC);
}
```

### Caching Strategies

#### Multi-Level Caching
```php
protected function getCachedRelationships(ModelBase $model, string $relationshipName): mixed {
    // Level 1: In-memory cache (fastest)
    $memoryKey = $this->buildMemoryCacheKey($model, $relationshipName);
    if (isset($this->relationshipCache[$memoryKey])) {
        return $this->relationshipCache[$memoryKey];
    }
    
    // Level 2: Redis/Memcached (fast)
    $cache = ServiceLocator::getCache();
    $cacheKey = $this->buildCacheKey($model, $relationshipName);
    
    if ($cache->has($cacheKey)) {
        $result = $cache->get($cacheKey);
        $this->relationshipCache[$memoryKey] = $result;
        return $result;
    }
    
    // Level 3: Database query (slowest)
    $result = $this->loadRelationshipFromDatabase($model, $relationshipName);
    
    // Cache the result at both levels
    $cache->set($cacheKey, $result, $this->getCacheTTL());
    $this->relationshipCache[$memoryKey] = $result;
    
    return $result;
}

protected function invalidateRelationshipCache(ModelBase $model): void {
    $cache = ServiceLocator::getCache();
    $pattern = $this->buildCacheKeyPattern($model);
    
    // Clear Redis/Memcached
    $cache->deleteByPattern($pattern);
    
    // Clear in-memory cache
    $this->relationshipCache = array_filter(
        $this->relationshipCache,
        fn($key) => !str_starts_with($key, $pattern),
        ARRAY_FILTER_USE_KEY
    );
}
```

#### Cache Invalidation Strategy
```php
public function addRelation(ModelBase $modelA, ModelBase $modelB, array $additionalData = []): bool {
    $success = $this->performAddRelation($modelA, $modelB, $additionalData);
    
    if ($success) {
        // Invalidate cache for both models
        $this->invalidateRelationshipCache($modelA);
        $this->invalidateRelationshipCache($modelB);
        
        // Invalidate related model caches if needed
        $this->invalidateRelatedModelCaches($modelA, $modelB);
    }
    
    return $success;
}
```

### Memory Management

#### Lazy Loading with Memory Limits
```php
protected int $maxInMemoryRelationships = 1000;
protected array $relationshipLoadOrder = [];

public function getRelated(string $relationshipName): mixed {
    // Check memory usage and cleanup if needed
    $this->enforceMemoryLimits();
    
    if (!isset($this->relationshipCache[$relationshipName])) {
        $this->relationshipCache[$relationshipName] = $this->loadRelationship($relationshipName);
        $this->relationshipLoadOrder[] = $relationshipName;
    }
    
    return $this->relationshipCache[$relationshipName];
}

private function enforceMemoryLimits(): void {
    while (count($this->relationshipCache) >= $this->maxInMemoryRelationships) {
        $oldestRelationship = array_shift($this->relationshipLoadOrder);
        unset($this->relationshipCache[$oldestRelationship]);
    }
}
```

#### Streaming for Large Result Sets
```php
public function getRelatedRecordsStreaming(ModelBase $model, callable $callback): void {
    $batchSize = 500;
    $offset = 0;
    
    do {
        $batch = $this->getRelatedRecordsBatch($model, $batchSize, $offset);
        
        foreach ($batch as $record) {
            $callback($record);
        }
        
        $offset += $batchSize;
    } while (count($batch) === $batchSize);
}
```

### Performance Monitoring and Metrics

#### Query Performance Tracking
```php
protected function trackQueryPerformance(string $queryType, callable $queryCallback): mixed {
    $startTime = microtime(true);
    $startMemory = memory_get_usage();
    
    try {
        $result = $queryCallback();
        
        $this->logPerformanceMetrics($queryType, [
            'execution_time' => microtime(true) - $startTime,
            'memory_used' => memory_get_usage() - $startMemory,
            'result_count' => is_array($result) ? count($result) : 1,
            'status' => 'success'
        ]);
        
        return $result;
    } catch (\Exception $e) {
        $this->logPerformanceMetrics($queryType, [
            'execution_time' => microtime(true) - $startTime,
            'memory_used' => memory_get_usage() - $startMemory,
            'status' => 'error',
            'error' => $e->getMessage()
        ]);
        
        throw $e;
    }
}
```

#### Performance Optimization Recommendations
```php
public function getPerformanceRecommendations(ModelBase $model): array {
    $recommendations = [];
    
    // Check for N+1 query problems
    if ($this->detectNPlusOneQueries($model)) {
        $recommendations[] = [
            'type' => 'n_plus_one',
            'message' => 'Consider using eager loading with withRelationships()',
            'severity' => 'high'
        ];
    }
    
    // Check for missing indexes
    $missingIndexes = $this->detectMissingIndexes();
    if (!empty($missingIndexes)) {
        $recommendations[] = [
            'type' => 'missing_indexes',
            'message' => 'Missing indexes detected: ' . implode(', ', $missingIndexes),
            'severity' => 'medium'
        ];
    }
    
    // Check cache hit rates
    $cacheHitRate = $this->getCacheHitRate();
    if ($cacheHitRate < 0.8) {
        $recommendations[] = [
            'type' => 'low_cache_hit_rate',
            'message' => "Cache hit rate is {$cacheHitRate}%, consider increasing TTL or warming cache",
            'severity' => 'medium'
        ];
    }
    
    return $recommendations;
}
```

## Comprehensive Edge Case Handling

### Temporal Relationships
Relationships that are valid only during specific time periods:

```php
[
    'type' => 'ManyToMany',
    'modelA' => 'User',
    'modelB' => 'Role',
    'additionalFields' => [
        'valid_from' => [
            'type' => 'DateTimeField',
            'required' => true,
            'default' => 'CURRENT_TIMESTAMP'
        ],
        'valid_until' => [
            'type' => 'DateTimeField',
            'required' => false,
            'default' => null // NULL means no expiration
        ]
    ]
]

// Query for relationships valid at specific time
public function getRelatedAtTime(ModelBase $model, \DateTime $time): array {
    $sql = "SELECT * FROM {$this->getTableName()} 
            WHERE {$this->getModelIdField($model)} = ? 
            AND valid_from <= ? 
            AND (valid_until IS NULL OR valid_until >= ?)";
    
    return $this->executeQuery($sql, [
        $model->get('id'),
        $time->format('Y-m-d H:i:s'),
        $time->format('Y-m-d H:i:s')
    ]);
}
```




### Data Consistency and Integrity Checks
Automated consistency validation for complex relationships:

```php
public function validateDataConsistency(): array {
    $inconsistencies = [];
    
    // Check for orphaned relationship records
    $orphanedRecords = $this->findOrphanedRelationships();
    if (!empty($orphanedRecords)) {
        $inconsistencies[] = [
            'type' => 'orphaned_relationships',
            'count' => count($orphanedRecords),
            'sample_ids' => array_slice($orphanedRecords, 0, 5)
        ];
    }
    
    // Check for duplicate relationships (when uniqueness is required)
    if ($this->isOneToOne()) {
        $duplicates = $this->findDuplicateRelationships();
        if (!empty($duplicates)) {
            $inconsistencies[] = [
                'type' => 'duplicate_relationships',
                'count' => count($duplicates)
            ];
        }
    }
    
    // Check referential integrity
    $brokenReferences = $this->findBrokenReferences();
    if (!empty($brokenReferences)) {
        $inconsistencies[] = [
            'type' => 'broken_references',
            'count' => count($brokenReferences)
        ];
    }
    
    return $inconsistencies;
}

public function repairDataInconsistencies(array $inconsistencies): bool {
    foreach ($inconsistencies as $issue) {
        switch ($issue['type']) {
            case 'orphaned_relationships':
                $this->cleanupOrphanedRelationships();
                break;
            case 'duplicate_relationships':
                $this->removeDuplicateRelationships();
                break;
            case 'broken_references':
                $this->repairBrokenReferences();
                break;
        }
    }
    
    return true;
}
```

## Testing Strategy Enhancement

### Testing Framework Structure
The relationship system requires comprehensive testing at multiple levels to ensure reliability and performance.

#### Unit Testing Strategy
```php
// Test structure for each relationship type
namespace Gravitycar\Tests\Unit\Relationships;

class OneToOneRelationshipTest extends TestCase {
    private OneToOneRelationship $relationship;
    private Logger $mockLogger;
    
    protected function setUp(): void {
        $this->mockLogger = $this->createMock(Logger::class);
        $this->relationship = new OneToOneRelationship([
            'name' => 'user_profile',
            'type' => 'OneToOne',
            'modelA' => 'User',
            'modelB' => 'Profile'
        ], $this->mockLogger);
    }
    
    public function testTableNameGeneration(): void {
        $expectedTableName = 'rel_1_user_1_profile';
        $this->assertEquals($expectedTableName, $this->relationship->getTableName());
    }
    
    public function testMetadataValidation(): void {
        $this->expectException(GCException::class);
        new OneToOneRelationship([
            'name' => 'invalid',
            'type' => 'OneToOne'
            // Missing required modelA and modelB
        ], $this->mockLogger);
    }
    
    public function testDynamicFieldGeneration(): void {
        $fields = $this->relationship->getDynamicFields();
        $this->assertArrayHasKey('user_id', $fields);
        $this->assertArrayHasKey('profile_id', $fields);
        $this->assertEquals('IDField', $fields['user_id']['type']);
    }
}
```

#### Integration Testing Strategy
```php
// Database integration tests
class RelationshipDatabaseIntegrationTest extends DatabaseTestCase {
    public function testOneToOneRelationshipCRUD(): void {
        // Create test models
        $user = $this->createTestUser();
        $profile = $this->createTestProfile();
        
        // Test relationship creation
        $relationship = new OneToOneRelationship($this->getTestMetadata(), $this->logger);
        $this->assertTrue($relationship->addRelation($user, $profile));
        
        // Test relationship retrieval
        $relatedProfile = $relationship->getRelatedRecord($user);
        $this->assertEquals($profile->get('id'), $relatedProfile->get('id'));
        
        // Test relationship deletion
        $this->assertTrue($relationship->removeRelation($user, $profile));
        $this->assertNull($relationship->getRelatedRecord($user));
    }
    
    public function testCascadeDeleteBehavior(): void {
        $user = $this->createTestUser();
        $profile = $this->createTestProfile();
        
        $relationship = new OneToOneRelationship([
            'name' => 'user_profile',
            'type' => 'OneToOne',
            'modelA' => 'User', 
            'modelB' => 'Profile',
            'constraints' => ['cascadeDelete' => 'cascade']
        ], $this->logger);
        
        $relationship->addRelation($user, $profile);
        
        // Delete user should cascade delete profile
        $this->assertTrue($relationship->handleModelDeletion($user, 'cascade'));
        $this->assertTrue($profile->isDeleted());
    }
}
```

#### Performance Testing Strategy
```php
class RelationshipPerformanceTest extends TestCase {
    public function testBatchOperationPerformance(): void {
        // Create large dataset
        $user = $this->createTestUser();
        $roles = $this->createTestRoles(1000); // Create 1000 test roles
        
        $relationship = new ManyToManyRelationship($this->getTestMetadata(), $this->logger);
        
        $startTime = microtime(true);
        $relationship->addMultipleRelationsBatch($user, $roles);
        $executionTime = microtime(true) - $startTime;
        
        // Should complete batch operation within reasonable time
        $this->assertLessThan(5.0, $executionTime, 'Batch operation took too long');
        
        // Verify all relationships were created
        $relatedRoles = $relationship->getRelatedRecords($user);
        $this->assertCount(1000, $relatedRoles);
    }
    
    public function testQueryCacheEffectiveness(): void {
        $user = $this->createTestUser();
        $relationship = new OneToManyRelationship($this->getTestMetadata(), $this->logger);
        
        // First query - should hit database
        $startTime = microtime(true);
        $posts1 = $relationship->getRelatedRecords($user);
        $firstQueryTime = microtime(true) - $startTime;
        
        // Second query - should hit cache
        $startTime = microtime(true);
        $posts2 = $relationship->getRelatedRecords($user);
        $secondQueryTime = microtime(true) - $startTime;
        
        // Cache should be significantly faster
        $this->assertLessThan($firstQueryTime * 0.5, $secondQueryTime);
        $this->assertEquals($posts1, $posts2);
    }
}
```

#### Edge Case Testing
```php
class RelationshipEdgeCaseTest extends TestCase {
    public function testTemporalRelationship(): void {
        $user = $this->createTestUser();
        $role = $this->createTestRole();
        
        $relationship = new ManyToManyRelationship([
            'name' => 'user_roles_temporal',
            'type' => 'ManyToMany',
            'modelA' => 'User',
            'modelB' => 'Role',
            'temporalFields' => [
                'valid_from' => ['type' => 'DateTimeField'],
                'valid_until' => ['type' => 'DateTimeField']
            ]
        ], $this->logger);
        
        $validFrom = new \DateTime('2025-01-01');
        $validUntil = new \DateTime('2025-12-31');
        
        $this->assertTrue($relationship->addRelation($user, $role, [
            'valid_from' => $validFrom->format('Y-m-d H:i:s'),
            'valid_until' => $validUntil->format('Y-m-d H:i:s')
        ]));
        
        // Test relationship is valid during period
        $currentDate = new \DateTime('2025-06-01');
        $relatedRoles = $relationship->getRelatedAtTime($user, $currentDate);
        $this->assertCount(1, $relatedRoles);
        
        // Test relationship is not valid outside period
        $futureDate = new \DateTime('2026-01-01');
        $relatedRoles = $relationship->getRelatedAtTime($user, $futureDate);
        $this->assertCount(0, $relatedRoles);
    }
}
```

#### Automated Testing Pipeline
```yaml
# phpunit.xml configuration for relationship testing
<?xml version="1.0" encoding="UTF-8"?>
<phpunit bootstrap="vendor/autoload.php"
         colors="true"
         processIsolation="false"
         stopOnFailure="false">
    <testsuites>
        <testsuite name="Relationship Unit Tests">
            <directory>Tests/Unit/Relationships</directory>
        </testsuite>
        <testsuite name="Relationship Integration Tests">
            <directory>Tests/Integration/Relationships</directory>
        </testsuite>
    </testsuites>
    
    <coverage processUncoveredFiles="true">
        <include>
            <directory suffix=".php">src/Relationships</directory>
        </include>
    </coverage>
</phpunit>
```

## Documentation Completion and Implementation Guidelines

### Complete Implementation Checklist

#### Phase 1: Core Infrastructure
- [ ] **RelationshipBase.php** - Abstract base class with common functionality
- [ ] **Metadata validation system** - Comprehensive validation for all relationship types
- [ ] **Table name generation** - Handle MySQL length limits and naming conventions
- [ ] **Dynamic field generation** - Create ID fields and additional fields automatically
- [ ] **ServiceLocator integration** - Proper dependency injection support

#### Phase 2: Relationship Type Implementations
- [ ] **OneToOneRelationship.php** - Complete implementation with unique constraints
- [ ] **OneToManyRelationship.php** - Handle "one" and "many" side operations
- [ ] **ManyToManyRelationship.php** - Support for additional fields and bulk operations
- [ ] **PolymorphicRelationship.php** - Support for multiple target model types

#### Phase 3: Advanced Features
- [ ] **Cascade operations** - Complete cascade delete/restore system
- [ ] **Bidirectional access** - Automatic inverse relationship generation
- [ ] **Performance optimizations** - Caching, eager loading, batch operations
- [ ] **Edge case handling** - Temporal, conditional, hierarchical relationships

#### Phase 4: Integration and Testing
- [ ] **ModelBase integration** - Relationship initialization in models
- [ ] **SchemaGenerator updates** - Create join tables automatically
- [ ] **DatabaseConnector updates** - Support relationship queries
- [ ] **Comprehensive test suite** - Unit, integration, performance, and stress tests

### API Usage Examples

#### Basic Relationship Usage
```php
// Define relationship in model metadata
// src/Models/User/user_metadata.php
return [
    'name' => 'User',
    'table' => 'users',
    'fields' => [
        // ... field definitions
    ],
    'relationships' => [
        'user_posts' => [
            'type' => 'OneToMany',
            'modelOne' => 'User',
            'modelMany' => 'Post',
            'constraints' => [
                'cascadeDelete' => 'restrict'
            ]
        ],
        'user_roles' => [
            'type' => 'ManyToMany',
            'modelA' => 'User',
            'modelB' => 'Role',
            'additionalFields' => [
                'assigned_at' => [
                    'type' => 'DateTimeField',
                    'default' => 'CURRENT_TIMESTAMP'
                ]
            ]
        ]
    ]
];

// Usage in application code
$user = User::findById('user-123');

// Get related posts (OneToMany)
$posts = $user->getRelated('user_posts');
foreach ($posts as $post) {
    echo $post->get('title') . "\n";
}

// Get related roles (ManyToMany)
$roles = $user->getRelated('user_roles');
foreach ($roles as $role) {
    echo $role->get('name') . "\n";
}

// Add new relationship
$newRole = Role::findById('role-456');
$userRolesRelationship = $user->getRelationship('user_roles');
$userRolesRelationship->addRelation($user, $newRole, [
    'assigned_by' => 'admin-user-id'
]);
```

#### Advanced Relationship Features
```php
// Temporal relationships
$relationship = new ManyToManyRelationship([
    'name' => 'user_roles_temporal',
    'type' => 'ManyToMany',
    'modelA' => 'User',
    'modelB' => 'Role',
    'temporalFields' => [
        'valid_from' => ['type' => 'DateTimeField'],
        'valid_until' => ['type' => 'DateTimeField']
    ]
], $logger);

// Get roles valid at specific time
$currentRoles = $relationship->getRelatedAtTime($user, $currentDate);

// Polymorphic relationships
$comment = Comment::findById('comment-123');
$commentableRelationship = $comment->getRelationship('commentable');
$relatedContent = $commentableRelationship->getPolymorphicRelation($comment);

if ($relatedContent instanceof Post) {
    echo "Comment on post: " . $relatedContent->get('title');
} elseif ($relatedContent instanceof Video) {
    echo "Comment on video: " . $relatedContent->get('title');
}

// Hierarchical relationships
$category = Category::findById('category-123');
$hierarchyRelationship = $category->getRelationship('category_hierarchy');

$ancestors = $hierarchyRelationship->getAncestors($category);
$descendants = $hierarchyRelationship->getDescendants($category);

// Move category to new parent
$newParent = Category::findById('new-parent-456');
$hierarchyRelationship->moveSubtree($category, $newParent);
```

### Performance Best Practices

#### Query Optimization
```php
// Use eager loading to prevent N+1 queries
$users = User::withRelationships(['user_posts', 'user_roles'])->findAll();

// Use pagination for large result sets
$relationship = new OneToManyRelationship($metadata, $logger);
$paginatedPosts = $relationship->getRelatedPaginated($user, $page = 1, $perPage = 20);

// Use batch operations for bulk updates
$relationship->addMultipleRelationsBatch($user, $newRoles, ['assigned_by' => 'admin']);
```

#### Caching Strategies
```php
// Configure cache TTL in relationship metadata
[
    'type' => 'ManyToMany',
    'modelA' => 'User',
    'modelB' => 'Role',
    'caching' => [
        'enabled' => true,
        'ttl' => 3600, // 1 hour
        'invalidateOnChange' => true
    ]
]

// Manual cache control
$relationship->clearCache($user);
$relationship->warmCache($user);
```

### Migration and Deployment Guide

#### Database Schema Updates
```php
// Schema migration for existing applications
class AddRelationshipTables extends Migration {
    public function up(): void {
        $schemaGenerator = ServiceLocator::getSchemaGenerator();
        
        // Generate relationship tables from metadata
        $relationships = MetadataEngine::getAllRelationships();
        foreach ($relationships as $relationship) {
            $schemaGenerator->createRelationshipTable($relationship);
        }
    }
    
    public function down(): void {
        // Drop relationship tables if needed
        $relationships = MetadataEngine::getAllRelationships();
        foreach ($relationships as $relationship) {
            $this->dropTable($relationship->getTableName());
        }
    }
}
```

#### Configuration Updates
```php
// config.php updates for relationship system
return [
    // ...existing config...
    'relationships' => [
        'cache_enabled' => true,
        'cache_ttl' => 3600,
        'batch_size' => 1000,
        'max_depth' => 10, // For hierarchical relationships
        'performance_monitoring' => true
    ]
];
```

### Troubleshooting Guide

#### Common Issues and Solutions

**Issue: Circular dependency detected**
```php
// Problem: Models have circular relationship references
// Solution: Use lazy loading or break circular dependencies
[
    'type' => 'OneToMany',
    'modelOne' => 'User',
    'modelMany' => 'Post',
    'lazyLoad' => true, // Prevents circular loading
    'dependsOn' => [] // Explicitly define dependencies
]
```

**Issue: Table name too long**
```php
// Problem: Generated table name exceeds database limits
// Solution: Use custom table name or abbreviations
[
    'type' => 'ManyToMany',
    'modelA' => 'VeryLongModelName',
    'modelB' => 'AnotherVeryLongModelName',
    'tableName' => 'rel_vlmn_avlmn', // Custom short name
    'constraints' => [
        'abbreviations' => [
            'VeryLongModelName' => 'vlmn',
            'AnotherVeryLongModelName' => 'avlmn'
        ]
    ]
]
```

**Issue: Poor performance with large datasets**
```php
// Problem: Slow queries on large relationship tables
// Solution: Add appropriate indexes and use pagination
[
    'type' => 'ManyToMany',
    'modelA' => 'User',
    'modelB' => 'Role',
    'indexes' => [
        ['fields' => ['user_id'], 'type' => 'index'],
        ['fields' => ['role_id'], 'type' => 'index'],
        ['fields' => ['user_id', 'role_id'], 'type' => 'unique']
    ],
    'queryOptimizations' => [
        'defaultLimit' => 100,
        'useIndexHints' => true
    ]
]
```

### Future Enhancements

#### Planned Features
1. **GraphQL Integration** - Support for GraphQL relationship queries
2. **Event System** - Relationship change events for real-time updates
3. **Audit Trail** - Comprehensive tracking of relationship changes
4. **Advanced Caching** - Multi-level caching with cache warming
5. **Analytics** - Relationship usage analytics and optimization recommendations
6. **Visual Tools** - Relationship diagram generation and visualization
7. **Import/Export** - Bulk relationship data management tools

#### Extension Points
- Custom relationship types via plugin system
- External data source integration (APIs, other databases)
- Advanced validation rules and business logic
- Integration with workflow engines
- Real-time synchronization capabilities

---

## Summary

This comprehensive RelationshipBase documentation provides:

âœ… **Complete Metadata Structure** - Detailed specifications for all relationship types
âœ… **Bidirectional Relationship Management** - Automatic inverse relationships  
âœ… **Advanced Query Methods** - Optimized query patterns with caching
âœ… **Cascade Operations** - Complete data integrity management
âœ… **Edge Case Handling** - Support for complex relationship scenarios
âœ… **Performance Optimization** - Caching, indexing, and batch operations
âœ… **Comprehensive Testing Strategy** - Unit, integration, performance, and stress tests
âœ… **Implementation Guidelines** - Complete development and deployment guidance

The relationship system is now fully specified and ready for implementation, providing a robust foundation for complex data relationships in the Gravitycar Framework.
